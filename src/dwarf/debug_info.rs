//! Parse the `.debug_info` section to get Debug Information Entries.
//!
//! It supports DWARFv4 now. (See https://dwarfstd.org/doc/DWARF4.pdf)
//! It parse DIEs from the `.debug_info` section and Abbreviations
//! from the `.debg_abbrev` section.
//!
//! The `.debug_info` section is a list of (Compile-)Units.  Every
//! Unit comprises DIEs to carry debug information of a source file.
//! A Unit starts with a header to describe the size of this unit in
//! the section, the offset of its abbreviation table in the
//! `.debug_abbrev` section, ..., and DWARF version. (version 4)
//!
//! A DIE starts with an index encoded in LEB128 to the abbreviation
//! table of the Unit.  The abbreviation given by the index describle
//! the content, format and layout of a DIE.  The abbreviation index
//! starts from 1.  0 means a null entry.  DIEs in an Unit are
//! organized as a tree, parent-children.  Null entries are used to
//! signal the last sibling to end a level.
use super::constants::*;
use super::{decode_leb128_128, decode_leb128_128_s, decode_udword, decode_uhalf, decode_uword};
use crate::tools::extract_string;
use std::io::{Error, ErrorKind};
use std::iter::Iterator;
use std::mem;

fn decode_3bytes_usigned(data: &[u8]) -> u32 {
    data[0] as u32 | ((data[1] as u32) << 8) | ((data[2] as u32) << 16)
}

#[allow(dead_code)]
pub struct UnknownHeader {
    init_length: usize,
    bits64: bool,
    version: u16,
    unit_type: u8,
    hdr_size: usize,
}

#[allow(dead_code)]
pub struct CUHeaderV5 {
    init_length: usize,
    bits64: bool,
    version: u16,
    unit_type: u8,
    address_size: u8,
    debug_abbrev_offset: u64,
    hdr_size: usize,
}

#[allow(dead_code)]
pub struct CUHeaderV4 {
    init_length: usize,
    bits64: bool,
    version: u16,
    address_size: u8,
    debug_abbrev_offset: u64,
    hdr_size: usize,
}

/// The Unit header.
///
/// With DWARFv4, an unit header describe a compile unit followed by
/// DIEs of the unit in the `.debug_info` section.  DWARFv5 is much
/// more complicated.
#[allow(dead_code)]
pub enum UnitHeader {
    CompileV4(CUHeaderV4),
    CompileV5(CUHeaderV5),
    Unknown(UnknownHeader),
}

impl UnitHeader {
    fn unit_size(&self) -> usize {
        match self {
            UnitHeader::CompileV4(h) => h.init_length + (if h.bits64 { 12 } else { 4 }),
            UnitHeader::CompileV5(h) => h.init_length + (if h.bits64 { 12 } else { 4 }),
            UnitHeader::Unknown(h) => h.init_length + (if h.bits64 { 12 } else { 4 }),
        }
    }

    fn header_size(&self) -> usize {
        match self {
            UnitHeader::CompileV4(h) => h.hdr_size,
            UnitHeader::CompileV5(h) => h.hdr_size,
            UnitHeader::Unknown(h) => h.hdr_size,
        }
    }
}

#[derive(Clone)]
pub struct AbbrevAttr {
    name: u8,
    form: u8,
    opt: u128,
}

/// An abbreviation.
///
/// An abbreviation comprises a list of attributes and the formats of
/// their values.
pub struct Abbrev {
    /// The index to the abbreviation table.
    pub abbrev_code: u32,
    /// The type of the abbreviation.
    ///
    /// It can be a DW_TAG_compile (a compile unit),
    /// DW_TAG_subprogram, DW_TAG_variable, ... etc.
    pub tag: u8,
    pub has_children: bool,

    parsed_attrs: Vec<AbbrevAttr>,
}

impl Abbrev {
    pub fn attrs_iter<'b>(&'b self) -> AbbrevAttrIter<'b> {
        AbbrevAttrIter {
            abbrev: self,
            idx: 0,
        }
    }

    #[inline]
    pub fn all_attrs(&self) -> &[AbbrevAttr] {
        &self.parsed_attrs[..]
    }
}

unsafe impl Send for Abbrev {}
unsafe impl Sync for Abbrev {}

pub struct AbbrevAttrIter<'a> {
    abbrev: &'a Abbrev,
    idx: usize,
}

impl<'a> Iterator for AbbrevAttrIter<'a> {
    type Item = AbbrevAttr;

    #[inline(always)]
    fn next(&mut self) -> Option<Self::Item> {
        let parsed_attrs = &self.abbrev.parsed_attrs;
        if self.idx < parsed_attrs.len() {
            let idx = self.idx;
            self.idx += 1;
            return Some(parsed_attrs[idx].clone());
        }
        None
    }
}

/// Parse an abbreviation from a buffer.
#[inline(always)]
fn parse_abbrev(data: &[u8]) -> Option<(Abbrev, usize)> {
    let (abbrev_code, bytes) = decode_leb128_128(data)?;
    if abbrev_code == 0 {
        return Some((
            Abbrev {
                abbrev_code: 0,
                tag: 0,
                has_children: false,
                parsed_attrs: vec![],
            },
            1,
        ));
    }

    let mut pos = bytes as usize;
    let (tag, bytes) = decode_leb128_128(&data[pos..])?;
    pos += bytes as usize;
    let has_children = data[pos] == DW_CHILDREN_yes;
    pos += 1;

    let start_pos = pos;
    let mut parsed_attrs = Vec::<AbbrevAttr>::new();
    while pos < data.len() {
        if let Some((name, form, opt, bytes)) = parse_abbrev_attr(&data[pos..]) {
            pos += bytes;
            parsed_attrs.push(AbbrevAttr { name, form, opt });
            if form == 0 {
                break;
            }
        } else {
            break;
        }
    }

    Some((
        Abbrev {
            abbrev_code: abbrev_code as u32,
            tag: tag as u8,
            has_children,
            parsed_attrs,
        },
        pos,
    ))
}

/// Parse an attribute from a buffer.
#[inline(always)]
fn parse_abbrev_attr(data: &[u8]) -> Option<(u8, u8, u128, usize)> {
    let mut pos = 0;
    let (name, bytes) = decode_leb128_128(&data[pos..])?;
    pos += bytes as usize;
    let (form, bytes) = decode_leb128_128(&data[pos..])?;
    pos += bytes as usize;
    let opt = if form as u8 == DW_FORM_implicit_const || form as u8 == DW_FORM_indirect {
        let (c, bytes) = decode_leb128_128(&data[pos..])?;
        pos += bytes as usize;
        c
    } else {
        0
    };
    Some((name as u8, form as u8, opt, pos))
}

#[derive(Clone)]
pub enum AttrValue<'a> {
    #[allow(dead_code)]
    Signed(i64),
    Signed128(i128),
    Unsigned(u64),
    Unsigned128(u128),
    Bytes(&'a [u8]),
    String(&'a str),
}

/// Extract the value of an attribute from a data buffer.
///
/// # Arguments
///
/// * `data` - A buffer where the value is in.
/// * `form` - The formate of the value. (DW_FORM_*)
/// * `dwarf_sz` - Describe the DWARF format. (4 for 32-bits and 8 for 64-bits)
/// * `addr_sz` - The size of an address of the target platform. (4 for 32-bits and 8 for 64-bits)
fn extract_attr_value(
    data: &[u8],
    form: u8,
    dwarf_sz: usize,
    addr_sz: usize,
) -> Option<(AttrValue, usize)> {
    match form {
        DW_FORM_addr => {
            if addr_sz == 0x4 {
                if 4 <= data.len() {
                    Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
                } else {
                    None
                }
            } else {
                if 8 <= data.len() {
                    Some((AttrValue::Unsigned(decode_udword(data) as u64), 8))
                } else {
                    None
                }
            }
        }
        DW_FORM_block2 => {
            if 2 <= data.len() {
                let bytes = decode_uhalf(data);
                let fullsize = bytes as usize + 2;
                if fullsize <= data.len() {
                    Some((AttrValue::Bytes(&data[2..fullsize]), fullsize))
                } else {
                    None
                }
            } else {
                None
            }
        }
        DW_FORM_block4 => {
            if 2 <= data.len() {
                let bytes = decode_uword(data);
                let fullsize = bytes as usize + 2;
                if fullsize <= data.len() {
                    Some((AttrValue::Bytes(&data[2..fullsize]), fullsize))
                } else {
                    None
                }
            } else {
                None
            }
        }
        DW_FORM_data2 => {
            if 2 <= data.len() {
                let v = decode_uhalf(data);
                Some((AttrValue::Unsigned(v as u64), 2))
            } else {
                None
            }
        }
        DW_FORM_data4 => {
            if 4 <= data.len() {
                let v = decode_uword(data);
                Some((AttrValue::Unsigned(v as u64), 4))
            } else {
                None
            }
        }
        DW_FORM_data8 => {
            if 8 <= data.len() {
                let v = decode_udword(data);
                Some((AttrValue::Unsigned(v), 8))
            } else {
                None
            }
        }
        DW_FORM_string => {
            let s = extract_string(data, 0)?;
            if (s.len() + 1) <= data.len() {
                Some((AttrValue::String(s), s.len() + 1))
            } else {
                None
            }
        }
        DW_FORM_block => {
            let (sz, bytes) = decode_leb128_128(data)?;
            let fullsz = sz as usize + bytes as usize;
            if fullsz <= data.len() {
                Some((AttrValue::Bytes(&data[bytes as usize..fullsz]), fullsz))
            } else {
                None
            }
        }
        DW_FORM_block1 => {
            if data.len() < 1 {
                return None;
            }
            let sz = data[0];
            let fullsz = sz as usize + 1;
            if fullsz <= data.len() {
                Some((AttrValue::Bytes(&data[1..fullsz]), fullsz))
            } else {
                None
            }
        }
        DW_FORM_data1 => {
            if 1 <= data.len() {
                Some((AttrValue::Unsigned(data[0] as u64), 1))
            } else {
                None
            }
        }
        DW_FORM_flag => {
            if 1 <= data.len() {
                Some((AttrValue::Unsigned(data[0] as u64), 1))
            } else {
                None
            }
        }
        DW_FORM_sdata => {
            let (v, bytes) = decode_leb128_128_s(data)?;
            Some((AttrValue::Signed128(v), bytes as usize))
        }
        DW_FORM_strp => {
            if dwarf_sz == 0x4 {
                if 4 <= data.len() {
                    Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
                } else {
                    None
                }
            } else {
                if 8 <= data.len() {
                    Some((AttrValue::Unsigned(decode_udword(data) as u64), 8))
                } else {
                    None
                }
            }
        }
        DW_FORM_udata => {
            let (v, bytes) = decode_leb128_128(data)?;
            Some((AttrValue::Unsigned128(v), bytes as usize))
        }
        DW_FORM_ref_addr => {
            if dwarf_sz == 0x4 {
                if 4 <= data.len() {
                    Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
                } else {
                    None
                }
            } else {
                if 8 <= data.len() {
                    Some((AttrValue::Unsigned(decode_udword(data) as u64), 8))
                } else {
                    None
                }
            }
        }
        DW_FORM_ref1 => {
            if 1 <= data.len() {
                Some((AttrValue::Unsigned(data[0] as u64), 1))
            } else {
                None
            }
        }
        DW_FORM_ref2 => {
            if 2 <= data.len() {
                Some((AttrValue::Unsigned(decode_uhalf(data) as u64), 2))
            } else {
                None
            }
        }
        DW_FORM_ref4 => {
            if 4 <= data.len() {
                Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
            } else {
                None
            }
        }
        DW_FORM_ref8 => {
            if 8 <= data.len() {
                Some((AttrValue::Unsigned(decode_udword(data)), 8))
            } else {
                None
            }
        }
        DW_FORM_ref_udata => {
            let (v, bytes) = decode_leb128_128(data)?;
            Some((AttrValue::Unsigned128(v), bytes as usize))
        }
        DW_FORM_indirect => {
            let (f, bytes) = decode_leb128_128(data)?;
            let (v, sz) = extract_attr_value(&data[bytes as usize..], f as u8, dwarf_sz, addr_sz)?;
            Some((v, sz + bytes as usize))
        }
        DW_FORM_sec_offset => {
            if dwarf_sz == 0x4 {
                if 4 <= data.len() {
                    Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
                } else {
                    None
                }
            } else {
                if 8 <= data.len() {
                    Some((AttrValue::Unsigned(decode_udword(data) as u64), 8))
                } else {
                    None
                }
            }
        }
        DW_FORM_exprloc => {
            let (sz, bytes) = decode_leb128_128(data)?;
            let fullsz = sz as usize + bytes as usize;
            Some((AttrValue::Bytes(&data[bytes as usize..fullsz]), fullsz))
        }
        DW_FORM_flag_present => Some((AttrValue::Unsigned(0), 0)),
        DW_FORM_strx => {
            let (idx, bytes) = decode_leb128_128(data)?;
            Some((AttrValue::Unsigned(idx as u64), bytes as usize))
        }
        DW_FORM_addrx => {
            let (idx, bytes) = decode_leb128_128(data)?;
            Some((AttrValue::Unsigned(idx as u64), bytes as usize))
        }
        DW_FORM_ref_sup4 => {
            if 4 <= data.len() {
                let off = decode_uword(data);
                Some((AttrValue::Unsigned(off as u64), 4))
            } else {
                None
            }
        }
        DW_FORM_strp_sup => {
            if dwarf_sz == 0x4 {
                if 4 <= data.len() {
                    Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
                } else {
                    None
                }
            } else {
                if 8 <= data.len() {
                    Some((AttrValue::Unsigned(decode_udword(data) as u64), 8))
                } else {
                    None
                }
            }
        }
        DW_FORM_data16 => {
            if 16 <= data.len() {
                Some((AttrValue::Bytes(&data[..16]), 16))
            } else {
                None
            }
        }
        DW_FORM_line_strp => {
            if dwarf_sz == 0x4 {
                if 4 <= data.len() {
                    Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
                } else {
                    None
                }
            } else {
                if 8 <= data.len() {
                    Some((AttrValue::Unsigned(decode_udword(data) as u64), 8))
                } else {
                    None
                }
            }
        }
        DW_FORM_ref_sig8 => {
            if 8 <= data.len() {
                Some((AttrValue::Bytes(&data[..8]), 8))
            } else {
                None
            }
        }
        DW_FORM_implicit_const => Some((AttrValue::Unsigned(0), 0)),
        DW_FORM_loclistx => {
            let (idx, bytes) = decode_leb128_128(data)?;
            Some((AttrValue::Unsigned(idx as u64), bytes as usize))
        }
        DW_FORM_rnglistx => {
            let (idx, bytes) = decode_leb128_128(data)?;
            Some((AttrValue::Unsigned(idx as u64), bytes as usize))
        }
        DW_FORM_ref_sup8 => {
            if 8 <= data.len() {
                Some((AttrValue::Unsigned(decode_udword(data)), 8))
            } else {
                None
            }
        }
        DW_FORM_str1 => {
            if 1 <= data.len() {
                Some((AttrValue::Unsigned(data[0] as u64), 1))
            } else {
                None
            }
        }
        DW_FORM_str2 => {
            if 2 <= data.len() {
                Some((AttrValue::Unsigned(decode_uhalf(data) as u64), 2))
            } else {
                None
            }
        }
        DW_FORM_str3 => {
            if 3 <= data.len() {
                Some((AttrValue::Unsigned(decode_3bytes_usigned(data) as u64), 3))
            } else {
                None
            }
        }
        DW_FORM_str4 => {
            if 4 <= data.len() {
                Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
            } else {
                None
            }
        }
        DW_FORM_addrx1 => {
            if 1 <= data.len() {
                Some((AttrValue::Unsigned(data[0] as u64), 1))
            } else {
                None
            }
        }
        DW_FORM_addrx2 => {
            if 2 <= data.len() {
                Some((AttrValue::Unsigned(decode_uhalf(data) as u64), 2))
            } else {
                None
            }
        }
        DW_FORM_addrx3 => {
            if 3 <= data.len() {
                Some((AttrValue::Unsigned(decode_3bytes_usigned(data) as u64), 3))
            } else {
                None
            }
        }
        DW_FORM_addrx4 => {
            if 4 <= data.len() {
                Some((AttrValue::Unsigned(decode_uword(data) as u64), 4))
            } else {
                None
            }
        }
        _ => None,
    }
}

/// Parse all abbreviations of an abbreviation table of a compile
/// unit.
fn parse_cu_abbrevs(data: &[u8]) -> Option<(Vec<Abbrev>, usize)> {
    let mut pos = 0;
    let mut abbrevs = Vec::<Abbrev>::with_capacity(data.len() / 50); // Heuristic!

    while pos < data.len() {
        let (abbrev, bytes) = parse_abbrev(&data[pos..])?;
        pos += bytes;
        if abbrev.abbrev_code == 0x0 {
            return Some((abbrevs, pos));
        }
        abbrevs.push(abbrev);
    }
    None
}

#[inline(always)]
#[allow(dead_code)]
fn measure_attr_size(data: &[u8], form: u8, dwarf_sz: usize, addr_sz: usize) -> Option<usize> {
    match form {
        DW_FORM_addr => Some(addr_sz),
        DW_FORM_block2 => {
            let sz = decode_uhalf(data);
            Some(sz as usize + 2)
        }
        DW_FORM_block4 => {
            let sz = decode_uword(data);
            Some(sz as usize + 4)
        }
        DW_FORM_data2 => Some(2),
        DW_FORM_data4 => Some(4),
        DW_FORM_data8 => Some(8),
        DW_FORM_string => {
            let s = extract_string(data, 0)?;
            Some(s.len() + 1)
        }
        DW_FORM_block => {
            let (sz, bytes) = decode_leb128_128(data)?;
            Some(sz as usize + bytes as usize)
        }
        DW_FORM_block1 => {
            let sz = data[0];
            Some(sz as usize + 1)
        }
        DW_FORM_data1 => Some(1),
        DW_FORM_flag => Some(1),
        DW_FORM_sdata => {
            let (_v, bytes) = decode_leb128_128_s(data)?;
            Some(bytes as usize)
        }
        DW_FORM_strp => Some(dwarf_sz),
        DW_FORM_udata => {
            let (_v, bytes) = decode_leb128_128(data)?;
            Some(bytes as usize)
        }
        DW_FORM_ref_addr => Some(dwarf_sz),
        DW_FORM_ref1 => Some(1),
        DW_FORM_ref2 => Some(2),
        DW_FORM_ref4 => Some(4),
        DW_FORM_ref8 => Some(8),
        DW_FORM_ref_udata => {
            let (_v, bytes) = decode_leb128_128(data)?;
            Some(bytes as usize)
        }
        DW_FORM_indirect => {
            let (f, bytes) = decode_leb128_128(data)?;
            measure_attr_size(&data[bytes as usize..], f as u8, dwarf_sz, addr_sz)
        }
        DW_FORM_sec_offset => Some(dwarf_sz),
        DW_FORM_exprloc => {
            let (sz, bytes) = decode_leb128_128(data)?;
            Some(sz as usize + bytes as usize)
        }
        DW_FORM_flag_present => Some(0),
        DW_FORM_strx => {
            let (_v, bytes) = decode_leb128_128(data)?;
            Some(bytes as usize)
        }
        DW_FORM_addrx => {
            let (_v, bytes) = decode_leb128_128(data)?;
            Some(bytes as usize)
        }
        DW_FORM_ref_sup4 => Some(4),
        DW_FORM_strp_sup => Some(dwarf_sz),
        DW_FORM_data16 => Some(16),
        DW_FORM_line_strp => Some(dwarf_sz),
        DW_FORM_ref_sig8 => Some(8),
        DW_FORM_implicit_const => Some(0),
        DW_FORM_loclistx => {
            let (_v, bytes) = decode_leb128_128(data)?;
            Some(bytes as usize)
        }
        DW_FORM_rnglistx => {
            let (_v, bytes) = decode_leb128_128(data)?;
            Some(bytes as usize)
        }
        DW_FORM_ref_sup8 => Some(8),
        DW_FORM_str1 => Some(1),
        DW_FORM_str2 => Some(2),
        DW_FORM_str3 => Some(3),
        DW_FORM_str4 => Some(4),
        DW_FORM_addrx1 => Some(1),
        DW_FORM_addrx2 => Some(2),
        DW_FORM_addrx3 => Some(3),
        DW_FORM_addrx4 => Some(4),
        _ => None,
    }
}

/// Parse a Unit header from a buffer.
///
/// The buffer includes the data from the `.debug_info` section.
fn parse_unit_header(data: &[u8]) -> Option<UnitHeader> {
    if data.len() < 4 {
        return None;
    }

    let mut pos = 0;
    let mut init_length = decode_uword(data) as usize;
    pos += 4;

    let bits64 = init_length == 0xffffffff;
    if bits64 {
        if (pos + 8) > data.len() {
            return None;
        }
        init_length = decode_udword(&data[pos..]) as usize;
        pos += 8;
    }

    if (pos + 2) > data.len() {
        return None;
    }
    let version = decode_uhalf(&data[pos..]);
    pos += 2;

    if version == 0x4 {
        let debug_abbrev_offset: u64 = if bits64 {
            if (pos + 8) > data.len() {
                return None;
            }
            let v = decode_udword(&data[pos..]);
            pos += 8;
            v
        } else {
            if (pos + 4) > data.len() {
                return None;
            }
            let v = decode_uword(&data[pos..]);
            pos += 4;
            v as u64
        };
        let address_size = data[pos];
        pos += 1;
        return Some(UnitHeader::CompileV4(CUHeaderV4 {
            init_length,
            bits64,
            version,
            debug_abbrev_offset,
            address_size,
            hdr_size: pos as usize,
        }));
    }

    if (pos + 1) > data.len() {
        return None;
    }
    let unit_type = data[pos];
    pos += 1;

    match unit_type {
        DW_UT_compile => {
            if (pos + 1) > data.len() {
                return None;
            }
            let address_size = data[pos];
            pos += 1;

            let debug_abbrev_offset: u64 = if bits64 {
                if (pos + 8) > data.len() {
                    return None;
                }
                let v = decode_udword(&data[pos..]);
                pos += 8;
                v
            } else {
                if (pos + 4) > data.len() {
                    return None;
                }
                let v = decode_uword(&data[pos..]);
                pos += 4;
                v as u64
            };
            Some(UnitHeader::CompileV5(CUHeaderV5 {
                init_length,
                bits64,
                version,
                unit_type,
                address_size,
                debug_abbrev_offset,
                hdr_size: pos as usize,
            }))
        }
        _ => Some(UnitHeader::Unknown(UnknownHeader {
            init_length,
            bits64,
            version,
            unit_type,
            hdr_size: pos as usize,
        })),
    }
}

/// Debug Information Entry.
pub struct DIE<'a> {
    pub tag: u8,
    pub offset: u64,
    pub abbrev: Option<&'a Abbrev>,
    abbrev_attrs: &'a [AbbrevAttr],
    abbrev_attrs_idx: usize,
    data: &'a [u8],
    dieiter: &'a mut DIEIter<'a>,
    reading_offset: usize,
    done: bool,
}

impl<'a> DIE<'a> {
    #[inline(always)]
    pub fn exhaust(&mut self) -> Result<(), Error> {
        let abbrev_attrs = self.abbrev_attrs;

        while self.abbrev_attrs_idx < abbrev_attrs.len() {
            let attr = &abbrev_attrs[self.abbrev_attrs_idx];
            self.abbrev_attrs_idx += 1;

            if attr.form == 0 {
                continue;
            }
            let bytes = if let Some(bytes) = measure_attr_size(
                &self.data[self.reading_offset..],
                attr.form,
                self.dieiter.dwarf_sz,
                self.dieiter.addr_sz,
            ) {
                bytes
            } else {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "fail to parse attribute values",
                ));
            };
        }
        self.dieiter
            .die_finish_reading(self.reading_offset as usize);
        self.done = true;
        Ok(())
    }
}

impl<'a> Iterator for DIE<'a> {
    // name, form, opt, value
    type Item = (u8, u8, u128, AttrValue<'a>);

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        if self.done {
            return None;
        }
        if self.abbrev.is_none() {
            return None;
        }

        if self.abbrev_attrs_idx < self.abbrev_attrs.len() {
            let AbbrevAttr { name, form, opt } = self.abbrev_attrs[self.abbrev_attrs_idx];
            self.abbrev_attrs_idx += 1;

            #[cfg(debug)]
            if form == 0 {
                assert_eq!(self.abbrev_off, abbrev.attrs.len());
            }
            if form == 0 {
                self.dieiter
                    .die_finish_reading(self.reading_offset as usize);
                self.done = true;
                return None;
            }

            let (value, bytes) = extract_attr_value(
                &self.data[self.reading_offset..],
                form,
                self.dieiter.dwarf_sz,
                self.dieiter.addr_sz,
            )?;
            self.reading_offset += bytes as usize;
            return Some((name, form, opt, value));
        } else {
            self.dieiter
                .die_finish_reading(self.reading_offset as usize);
            self.done = true;
        }
        None
    }
}

/// The iterator of DIEs in an Unit.
pub struct DIEIter<'a> {
    data: &'a [u8],
    dwarf_sz: usize,
    addr_sz: usize,
    off: usize,
    cur_depth: usize,
    abbrevs: Vec<Abbrev>,
    abbrev: Option<&'a Abbrev>,
    die_reading_done: bool,
    done: bool,
}

impl<'a> DIEIter<'a> {
    pub fn die_finish_reading(&mut self, size: usize) {
        self.die_reading_done = true;
        self.off += size;
    }

    pub fn seek_to_sibling(&mut self, off: usize) {
        self.off = off;
        self.cur_depth -= 1;
        self.die_reading_done = true;
    }

    #[inline(always)]
    pub fn exhaust_die(&mut self) -> Result<(), Error> {
        assert!(
            !self.die_reading_done,
            "DIE should not have been exhausted!"
        );
        let abbrev = self.abbrev.unwrap();
        for attr in abbrev.all_attrs() {
            if attr.form == 0 {
                continue;
            }
            let bytes = if let Some(bytes) = measure_attr_size(
                &self.data[self.off..],
                attr.form,
                self.dwarf_sz,
                self.addr_sz,
            ) {
                bytes
            } else {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "fail to parse attribute values",
                ));
            };
            self.off += bytes;
        }
        self.die_reading_done = true;
        Ok(())
    }
}

impl<'a> Iterator for DIEIter<'a> {
    type Item = DIE<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if !self.die_reading_done {
            self.exhaust_die().unwrap();
        }
        if self.done {
            return None;
        }

        let saved_off = self.off;
        let (abbrev_idx, bytes) = decode_leb128_128(&self.data[self.off..])?;
        self.off += bytes as usize;
        if abbrev_idx == 0 {
            self.cur_depth -= 1;
            if self.cur_depth == 0 {
                self.done = true;
            }
            return Some(DIE {
                tag: 0,
                offset: saved_off as u64,
                abbrev: None,
                abbrev_attrs: &[],
                abbrev_attrs_idx: 0,
                data: &self.data[self.off..],
                dieiter: unsafe { mem::transmute(self) },
                reading_offset: 0,
                done: false,
            });
        }

        let abbrev = unsafe { mem::transmute(&self.abbrevs[abbrev_idx as usize - 1]) };
        self.abbrev = Some(abbrev);
        if abbrev.has_children {
            self.cur_depth += 1;
        }

        self.die_reading_done = false;
        Some(DIE {
            tag: abbrev.tag,
            offset: saved_off as u64,
            abbrev: Some(abbrev),
            abbrev_attrs: abbrev.all_attrs(),
            abbrev_attrs_idx: 0,
            data: &self.data[self.off..],
            dieiter: unsafe { mem::transmute(self) },
            reading_offset: 0,
            done: false,
        })
    }
}

/// The iterator of Units in the `.debug_info` section.
pub struct UnitIter<'a> {
    data: &'a [u8],
    abbrev_data: &'a [u8],
    pub off: usize,
}

impl<'a> UnitIter<'a> {
    pub fn new(data: &'a [u8], abbrev_data: &'a [u8]) -> UnitIter<'a> {
        UnitIter {
            data,
            abbrev_data,
            off: 0,
        }
    }
}

impl<'a> Iterator for UnitIter<'a> {
    type Item = (UnitHeader, DIEIter<'a>);

    fn next(&mut self) -> Option<Self::Item> {
        let off = self.off;
        let uh = parse_unit_header(&self.data[off..])?;
        let hdr_sz = uh.header_size();
        self.off += uh.unit_size();

        match uh {
            UnitHeader::CompileV4(ref cuh) => {
                let dwarf_sz = if cuh.bits64 { 8 } else { 4 };
                let addr_sz = cuh.address_size as usize;
                let (abbrevs, _) =
                    parse_cu_abbrevs(&self.abbrev_data[cuh.debug_abbrev_offset as usize..])?;
                Some((
                    uh,
                    DIEIter {
                        data: &self.data[off + hdr_sz..],
                        dwarf_sz,
                        addr_sz,
                        off: 0,
                        cur_depth: 0,
                        abbrevs,
                        abbrev: None,
                        die_reading_done: true,
                        done: false,
                    },
                ))
            }
            UnitHeader::CompileV5(ref cuh) => {
                let dwarf_sz = if cuh.bits64 { 8 } else { 4 };
                let addr_sz = cuh.address_size as usize;
                let (abbrevs, _) =
                    parse_cu_abbrevs(&self.abbrev_data[cuh.debug_abbrev_offset as usize..])?;
                Some((
                    uh,
                    DIEIter {
                        data: &self.data[off + hdr_sz..],
                        dwarf_sz,
                        addr_sz,
                        off: 0,
                        cur_depth: 0,
                        abbrevs,
                        abbrev: None,
                        die_reading_done: true,
                        done: false,
                    },
                ))
            }
            _ => self.next(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const test_info: [u8; 0x80a] = [
        0x06, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x1c, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x02, 0xb1, 0x8d,
        0x28, 0x00, 0x02, 0x15, 0x28, 0x42, 0x00, 0x02, 0xd7, 0x3e, 0x42, 0x00, 0x02, 0x59, 0x9e,
        0x31, 0x00, 0x03, 0xca, 0x06, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0x01, 0x01, 0x04, 0x7c,
        0x00, 0x00, 0x00, 0x00, 0x04, 0x81, 0x00, 0x00, 0x00, 0x01, 0x04, 0x87, 0x00, 0x00, 0x00,
        0x02, 0x04, 0x8e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x5a, 0x02, 0x00, 0x00,
        0x10, 0x08, 0x06, 0x82, 0x95, 0x22, 0x00, 0xff, 0x06, 0x00, 0x00, 0x08, 0x00, 0x06, 0x8d,
        0x01, 0x00, 0x00, 0x0c, 0x07, 0x00, 0x00, 0x08, 0x08, 0x07, 0x65, 0x02, 0x00, 0x00, 0x9f,
        0x02, 0x00, 0x00, 0x03, 0x42, 0x01, 0x64, 0x00, 0x00, 0x00, 0x01, 0x08, 0xf8, 0x06, 0x00,
        0x00, 0x77, 0xfa, 0x09, 0x00, 0x09, 0x25, 0x6e, 0x0a, 0x00, 0x01, 0x01, 0xb1, 0x06, 0xa1,
        0x07, 0x00, 0x00, 0x00, 0x07, 0xb2, 0x02, 0x00, 0x00, 0xe3, 0x02, 0x00, 0x00, 0x03, 0x4d,
        0x01, 0x64, 0x00, 0x00, 0x00, 0x01, 0x08, 0xf8, 0x06, 0x00, 0x00, 0x77, 0xfa, 0x09, 0x00,
        0x09, 0x25, 0x6e, 0x0a, 0x00, 0x01, 0x01, 0xb1, 0x06, 0xa1, 0x07, 0x00, 0x00, 0x09, 0x0e,
        0xa7, 0x16, 0x00, 0x01, 0x01, 0xb1, 0x06, 0xae, 0x07, 0x00, 0x00, 0x00, 0x07, 0xa0, 0x04,
        0x00, 0x00, 0xdc, 0x04, 0x00, 0x00, 0x03, 0x42, 0x01, 0x64, 0x00, 0x00, 0x00, 0x01, 0x08,
        0x3d, 0x07, 0x00, 0x00, 0x77, 0xfa, 0x09, 0x00, 0x09, 0x25, 0x6e, 0x0a, 0x00, 0x01, 0x01,
        0xb1, 0x06, 0xcb, 0x07, 0x00, 0x00, 0x00, 0x07, 0xef, 0x04, 0x00, 0x00, 0x20, 0x05, 0x00,
        0x00, 0x03, 0x4d, 0x01, 0x64, 0x00, 0x00, 0x00, 0x01, 0x08, 0x3d, 0x07, 0x00, 0x00, 0x77,
        0xfa, 0x09, 0x00, 0x09, 0x25, 0x6e, 0x0a, 0x00, 0x01, 0x01, 0xb1, 0x06, 0xcb, 0x07, 0x00,
        0x00, 0x09, 0x0e, 0xa7, 0x16, 0x00, 0x01, 0x01, 0xb1, 0x06, 0xd8, 0x07, 0x00, 0x00, 0x00,
        0x07, 0x65, 0x02, 0x00, 0x00, 0x9f, 0x02, 0x00, 0x00, 0x03, 0x42, 0x01, 0x64, 0x00, 0x00,
        0x00, 0x01, 0x08, 0xf8, 0x06, 0x00, 0x00, 0x77, 0xfa, 0x09, 0x00, 0x09, 0x25, 0x6e, 0x0a,
        0x00, 0x01, 0x01, 0xb1, 0x06, 0xa1, 0x07, 0x00, 0x00, 0x00, 0x07, 0xb2, 0x02, 0x00, 0x00,
        0xe3, 0x02, 0x00, 0x00, 0x03, 0x4d, 0x01, 0x64, 0x00, 0x00, 0x00, 0x01, 0x08, 0xf8, 0x06,
        0x00, 0x00, 0x77, 0xfa, 0x09, 0x00, 0x09, 0x25, 0x6e, 0x0a, 0x00, 0x01, 0x01, 0xb1, 0x06,
        0xa1, 0x07, 0x00, 0x00, 0x09, 0x0e, 0xa7, 0x16, 0x00, 0x01, 0x01, 0xb1, 0x06, 0xae, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x63, 0x01, 0x00, 0x00, 0x0a, 0x86, 0x01, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x0a, 0x05, 0x45, 0x40, 0x00, 0x00, 0x01, 0x05, 0x03, 0x51, 0x1f, 0x00, 0x40,
        0x08, 0x06, 0x73, 0xea, 0x2e, 0x00, 0x3d, 0x07, 0x00, 0x00, 0x04, 0x30, 0x06, 0xe1, 0xd9,
        0x2c, 0x00, 0x44, 0x07, 0x00, 0x00, 0x04, 0x34, 0x06, 0x1e, 0xf0, 0x05, 0x00, 0x3e, 0x00,
        0x00, 0x00, 0x01, 0x38, 0x06, 0xfb, 0xd7, 0x40, 0x00, 0x73, 0x03, 0x00, 0x00, 0x08, 0x00,
        0x06, 0xa3, 0x01, 0x00, 0x00, 0x73, 0x03, 0x00, 0x00, 0x08, 0x10, 0x06, 0x92, 0x38, 0x07,
        0x00, 0x52, 0x07, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x02, 0xa0, 0x88, 0x01, 0x00, 0x02,
        0xf9, 0x1b, 0x0f, 0x00, 0x02, 0xa0, 0x00, 0x00, 0x00, 0x0b, 0xad, 0x00, 0x00, 0x00, 0x2f,
        0x01, 0x00, 0x00, 0x02, 0x1d, 0xd1, 0x06, 0x00, 0x00, 0x01, 0x08, 0xca, 0x06, 0x00, 0x00,
        0x77, 0xfa, 0x09, 0x00, 0x08, 0xc8, 0x02, 0x00, 0x00, 0xd0, 0xf3, 0x2d, 0x00, 0x0c, 0xf9,
        0x1b, 0x0f, 0x00, 0x01, 0x9e, 0x06, 0xc8, 0x02, 0x00, 0x00, 0x09, 0xf1, 0x1c, 0x00, 0x00,
        0x01, 0x01, 0x9e, 0x06, 0xd1, 0x06, 0x00, 0x00, 0x00, 0x0b, 0x46, 0x03, 0x00, 0x00, 0xc8,
        0x03, 0x00, 0x00, 0x02, 0x1d, 0xd1, 0x06, 0x00, 0x00, 0x01, 0x08, 0xca, 0x06, 0x00, 0x00,
        0x77, 0xfa, 0x09, 0x00, 0x08, 0xcf, 0x02, 0x00, 0x00, 0xd0, 0xf3, 0x2d, 0x00, 0x09, 0xf9,
        0x1b, 0x0f, 0x00, 0x01, 0x01, 0xb8, 0x06, 0xcf, 0x02, 0x00, 0x00, 0x09, 0xf1, 0x1c, 0x00,
        0x00, 0x01, 0x01, 0xb8, 0x06, 0xd1, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0xf8, 0x03, 0x00,
        0x00, 0x07, 0x01, 0x04, 0x00, 0x00, 0x92, 0x04, 0x00, 0x00, 0x02, 0x6f, 0x01, 0xd1, 0x06,
        0x00, 0x00, 0x01, 0x08, 0xca, 0x06, 0x00, 0x00, 0x77, 0xfa, 0x09, 0x00, 0x09, 0xf1, 0x1c,
        0x00, 0x00, 0x01, 0x01, 0xb8, 0x06, 0xcf, 0x02, 0x00, 0x00, 0x09, 0xa0, 0x88, 0x01, 0x00,
        0x01, 0x01, 0xb8, 0x06, 0xd1, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xa9, 0x00,
        0x00, 0x00, 0x02, 0x20, 0xa4, 0x1f, 0x00, 0x0a, 0x4f, 0x8e, 0x25, 0x00, 0x00, 0x01, 0x05,
        0x6c, 0x8e, 0x25, 0x00, 0x08, 0x08, 0x08, 0xf8, 0x06, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00,
        0x06, 0x87, 0xce, 0x16, 0x00, 0xf8, 0x06, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02,
        0xa8, 0xcf, 0x2a, 0x00, 0x05, 0xb6, 0x8e, 0x2c, 0x00, 0x01, 0x01, 0x0d, 0xfe, 0x02, 0x00,
        0x00, 0x0e, 0xca, 0x06, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x00, 0x06, 0x97, 0x01, 0x00, 0x00,
        0x22, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0f, 0x01, 0x06, 0xc9, 0x31, 0x28, 0x00, 0x47,
        0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x97, 0x01, 0x00, 0x00, 0x01, 0x01, 0x08,
        0x29, 0x07, 0x00, 0x00, 0x77, 0xfa, 0x09, 0x00, 0x08, 0xa6, 0x01, 0x00, 0x00, 0xc3, 0x49,
        0x32, 0x00, 0x06, 0x9a, 0x01, 0x00, 0x00, 0x29, 0x07, 0x00, 0x00, 0x01, 0x01, 0x00, 0x05,
        0xc9, 0x31, 0x28, 0x00, 0x01, 0x01, 0x08, 0x29, 0x07, 0x00, 0x00, 0x77, 0xfa, 0x09, 0x00,
        0x08, 0xa6, 0x01, 0x00, 0x00, 0xc3, 0x49, 0x32, 0x00, 0x06, 0x9a, 0x01, 0x00, 0x00, 0xa6,
        0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x02, 0x03, 0x2d, 0x16, 0x00, 0x05, 0x36,
        0x4d, 0x01, 0x00, 0x10, 0x08, 0x0d, 0x7f, 0x03, 0x00, 0x00, 0x0e, 0x4b, 0x07, 0x00, 0x00,
        0x08, 0x00, 0x0f, 0x00, 0x06, 0x0e, 0xa6, 0x28, 0x00, 0xa3, 0x03, 0x00, 0x00, 0x08, 0x00,
        0x00, 0x0f, 0x01, 0x06, 0x9e, 0x01, 0x00, 0x00, 0xb4, 0x03, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x05, 0x0e, 0xa6, 0x28, 0x00, 0x10, 0x08, 0x08, 0xf8, 0x06, 0x00, 0x00, 0x77, 0xfa,
        0x09, 0x00, 0x00, 0x05, 0x9e, 0x01, 0x00, 0x00, 0x10, 0x08, 0x08, 0xf8, 0x06, 0x00, 0x00,
        0x77, 0xfa, 0x09, 0x00, 0x06, 0x9a, 0x01, 0x00, 0x00, 0xf8, 0x06, 0x00, 0x00, 0x08, 0x08,
        0x00, 0x00, 0x00, 0x02, 0x1c, 0xcd, 0x1e, 0x00, 0x02, 0x7b, 0x05, 0x00, 0x00, 0x10, 0xd0,
        0xc6, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x04, 0x00, 0x00, 0x01, 0x57, 0x8c, 0x05,
        0x00, 0x00, 0xc7, 0x05, 0x00, 0x00, 0x01, 0x9c, 0x06, 0xd1, 0x06, 0x00, 0x00, 0x11, 0x03,
        0x91, 0xe4, 0x00, 0xa0, 0x76, 0x29, 0x00, 0x01, 0x9c, 0x06, 0x3d, 0x07, 0x00, 0x00, 0x11,
        0x03, 0x91, 0xb8, 0x02, 0x4f, 0x2d, 0x02, 0x00, 0x01, 0x9c, 0x06, 0xd1, 0x06, 0x00, 0x00,
        0x12, 0x00, 0x00, 0x00, 0x00, 0x13, 0x03, 0x91, 0xe8, 0x00, 0x3f, 0x77, 0x11, 0x00, 0x01,
        0x01, 0x9d, 0x06, 0xf8, 0x06, 0x00, 0x00, 0x14, 0x07, 0x02, 0x00, 0x00, 0x22, 0xc7, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x9e, 0x06, 0x16, 0x15, 0x03,
        0x91, 0xc8, 0x02, 0x29, 0x02, 0x00, 0x00, 0x15, 0x03, 0x91, 0xd8, 0x02, 0x35, 0x02, 0x00,
        0x00, 0x00, 0x16, 0x81, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0xb3, 0x06, 0x0d,
        0x15, 0x03, 0x91, 0xf0, 0x03, 0x9b, 0x00, 0x00, 0x00, 0x16, 0xa9, 0x00, 0x00, 0x00, 0x60,
        0x00, 0x00, 0x00, 0x03, 0x43, 0x01, 0x0d, 0x15, 0x03, 0x91, 0xf8, 0x03, 0xc3, 0x00, 0x00,
        0x00, 0x15, 0x03, 0x91, 0x80, 0x04, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x41, 0xc8,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x13, 0x03, 0x91, 0xf8, 0x02,
        0x82, 0x25, 0x10, 0x00, 0x01, 0x01, 0xab, 0x06, 0xfc, 0x07, 0x00, 0x00, 0x13, 0x03, 0x91,
        0x80, 0x03, 0x1b, 0xa8, 0x16, 0x00, 0x01, 0x01, 0xab, 0x06, 0xfc, 0x07, 0x00, 0x00, 0x13,
        0x03, 0x91, 0x88, 0x03, 0x27, 0x52, 0x3a, 0x00, 0x01, 0x01, 0xab, 0x06, 0xfc, 0x07, 0x00,
        0x00, 0x13, 0x03, 0x91, 0x90, 0x03, 0x3a, 0xa8, 0x28, 0x00, 0x01, 0x01, 0xab, 0x06, 0xfc,
        0x07, 0x00, 0x00, 0x00, 0x14, 0x43, 0x02, 0x00, 0x00, 0xa8, 0xc8, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x01, 0xb8, 0x06, 0x0a, 0x15, 0x03, 0x91, 0xa0, 0x02,
        0x65, 0x02, 0x00, 0x00, 0x15, 0x03, 0x91, 0xc8, 0x03, 0x72, 0x02, 0x00, 0x00, 0x18, 0x86,
        0x02, 0x00, 0x00, 0xc8, 0xc8, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x02, 0x1e, 0x09, 0x15, 0x03, 0x91, 0xd8, 0x03, 0xa0, 0x02, 0x00, 0x00, 0x15, 0x03, 0x91,
        0xe0, 0x03, 0xad, 0x02, 0x00, 0x00, 0x00, 0x00, 0x17, 0x3d, 0xc9, 0x04, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x13, 0x03, 0x91, 0x98, 0x03, 0x82, 0x25, 0x10, 0x00,
        0x01, 0x01, 0xa6, 0x06, 0xfc, 0x07, 0x00, 0x00, 0x13, 0x03, 0x91, 0xa0, 0x03, 0x1b, 0xa8,
        0x16, 0x00, 0x01, 0x01, 0xa6, 0x06, 0xfc, 0x07, 0x00, 0x00, 0x13, 0x03, 0x91, 0xa8, 0x03,
        0x27, 0x52, 0x3a, 0x00, 0x01, 0x01, 0xa6, 0x06, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x17, 0x91,
        0xc9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x13, 0x03, 0x91, 0xb0,
        0x03, 0x82, 0x25, 0x10, 0x00, 0x01, 0x01, 0xa2, 0x06, 0xfc, 0x07, 0x00, 0x00, 0x13, 0x03,
        0x91, 0xb8, 0x03, 0x1b, 0xa8, 0x16, 0x00, 0x01, 0x01, 0xa2, 0x06, 0xfc, 0x07, 0x00, 0x00,
        0x00, 0x17, 0xbf, 0xc9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x13,
        0x03, 0x91, 0xc0, 0x03, 0x82, 0x25, 0x10, 0x00, 0x01, 0x01, 0x9f, 0x06, 0xfc, 0x07, 0x00,
        0x00, 0x00, 0x14, 0xde, 0x00, 0x00, 0x00, 0x1d, 0xca, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x71, 0x00, 0x00, 0x00, 0x01, 0xb4, 0x06, 0x0d, 0x15, 0x03, 0x91, 0x98, 0x04, 0xf8, 0x00,
        0x00, 0x00, 0x14, 0x06, 0x01, 0x00, 0x00, 0x39, 0xca, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x55, 0x00, 0x00, 0x00, 0x03, 0x43, 0x01, 0x0d, 0x15, 0x03, 0x91, 0xa0, 0x04, 0x20, 0x01,
        0x00, 0x00, 0x15, 0x03, 0x91, 0xa8, 0x04, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x14, 0x3b,
        0x01, 0x00, 0x00, 0xa6, 0xca, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00,
        0x01, 0xb5, 0x06, 0x0d, 0x15, 0x03, 0x91, 0xc0, 0x04, 0x55, 0x01, 0x00, 0x00, 0x14, 0x63,
        0x01, 0x00, 0x00, 0xc5, 0xca, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
        0x03, 0x43, 0x01, 0x0d, 0x15, 0x03, 0x91, 0xc8, 0x04, 0x7d, 0x01, 0x00, 0x00, 0x15, 0x03,
        0x91, 0xd0, 0x04, 0x8a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x83, 0x05, 0x00,
        0x00, 0x10, 0xc0, 0xcb, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x00, 0x00, 0x00, 0x01,
        0x57, 0xd7, 0x05, 0x00, 0x00, 0x28, 0x06, 0x00, 0x00, 0x01, 0x43, 0x03, 0xf5, 0x07, 0x00,
        0x00, 0x11, 0x02, 0x91, 0x10, 0xf1, 0x1c, 0x00, 0x00, 0x01, 0x43, 0x03, 0x44, 0x07, 0x00,
        0x00, 0x12, 0x90, 0x00, 0x00, 0x00, 0x19, 0x02, 0x91, 0x14, 0x27, 0x52, 0x3a, 0x00, 0x01,
        0x46, 0x03, 0x44, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x30, 0xcc, 0x04, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x01, 0x57, 0x36, 0x06, 0x00, 0x00, 0x69, 0x06,
        0x00, 0x00, 0x01, 0x80, 0x06, 0xf8, 0x06, 0x00, 0x00, 0x11, 0x02, 0x91, 0x14, 0xa0, 0x76,
        0x29, 0x00, 0x01, 0x80, 0x06, 0x3d, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x78,
        0x0a, 0x00, 0x00, 0x07, 0x01, 0x05, 0x7d, 0xdf, 0x28, 0x00, 0x10, 0x08, 0x06, 0x5a, 0x01,
        0x00, 0x00, 0xef, 0x06, 0x00, 0x00, 0x08, 0x00, 0x06, 0x13, 0xac, 0x2e, 0x00, 0xf8, 0x06,
        0x00, 0x00, 0x08, 0x08, 0x00, 0x1b, 0xca, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a,
        0xc2, 0x55, 0x03, 0x00, 0x07, 0x08, 0x1c, 0x9e, 0x01, 0x00, 0x00, 0x6e, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x1c, 0x19, 0x07, 0x00, 0x00, 0xee, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1d, 0xf2, 0x02, 0x00, 0x00, 0x1e, 0xff, 0x06, 0x00, 0x00, 0x1e, 0x30, 0x07,
        0x00, 0x00, 0x00, 0x1a, 0x48, 0x0a, 0x00, 0x00, 0x07, 0x00, 0x1c, 0xad, 0x01, 0x00, 0x00,
        0xf3, 0x50, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x12, 0x39, 0x29, 0x00, 0x07, 0x04,
        0x1a, 0x1c, 0xcd, 0x1e, 0x00, 0x10, 0x04, 0x1a, 0x83, 0x72, 0x06, 0x00, 0x07, 0x08, 0x05,
        0xd4, 0x01, 0x00, 0x00, 0x10, 0x08, 0x06, 0x7b, 0xc5, 0x3d, 0x00, 0x70, 0x07, 0x00, 0x00,
        0x08, 0x00, 0x06, 0xad, 0x01, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x08, 0x08, 0x00, 0x1b,
        0x79, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0xd9, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x1c, 0x8d, 0x07, 0x00, 0x00, 0xc8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8,
        0x06, 0x00, 0x00, 0x20, 0x9a, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x21, 0xb4, 0x01, 0x00,
        0x00, 0x08, 0x07, 0x1c, 0xf8, 0x06, 0x00, 0x00, 0x61, 0x6e, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x1c, 0xbb, 0x07, 0x00, 0x00, 0xee, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d,
        0xf2, 0x02, 0x00, 0x00, 0x1e, 0xa1, 0x07, 0x00, 0x00, 0x1e, 0x30, 0x07, 0x00, 0x00, 0x00,
        0x1c, 0x3d, 0x07, 0x00, 0x00, 0x9b, 0x2a, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xe5,
        0x07, 0x00, 0x00, 0x29, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xf2, 0x02, 0x00,
        0x00, 0x1e, 0xcb, 0x07, 0x00, 0x00, 0x1e, 0x30, 0x07, 0x00, 0x00, 0x00, 0x1a, 0x0f, 0x97,
        0x0b, 0x00, 0x02, 0x01, 0x1c, 0xca, 0x06, 0x00, 0x00, 0x72, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00,
    ];

    const test_abbrev: [u8; 0x19a] = [
        0x01, 0x11, 0x01, 0x25, 0x0e, 0x13, 0x05, 0x03, 0x0e, 0x10, 0x17, 0x1b, 0x0e, 0xb4, 0x42,
        0x19, 0x11, 0x01, 0x55, 0x17, 0x00, 0x00, 0x02, 0x39, 0x01, 0x03, 0x0e, 0x00, 0x00, 0x03,
        0x04, 0x01, 0x49, 0x13, 0x6d, 0x19, 0x03, 0x0e, 0x0b, 0x0b, 0x88, 0x01, 0x0f, 0x00, 0x00,
        0x04, 0x28, 0x00, 0x03, 0x0e, 0x1c, 0x0f, 0x00, 0x00, 0x05, 0x13, 0x01, 0x03, 0x0e, 0x0b,
        0x0b, 0x88, 0x01, 0x0f, 0x00, 0x00, 0x06, 0x0d, 0x00, 0x03, 0x0e, 0x49, 0x13, 0x88, 0x01,
        0x0f, 0x38, 0x0b, 0x00, 0x00, 0x07, 0x2e, 0x01, 0x6e, 0x0e, 0x03, 0x0e, 0x3a, 0x0b, 0x3b,
        0x05, 0x49, 0x13, 0x20, 0x0b, 0x00, 0x00, 0x08, 0x2f, 0x00, 0x49, 0x13, 0x03, 0x0e, 0x00,
        0x00, 0x09, 0x34, 0x00, 0x03, 0x0e, 0x88, 0x01, 0x0f, 0x3a, 0x0b, 0x3b, 0x05, 0x49, 0x13,
        0x00, 0x00, 0x0a, 0x13, 0x00, 0x03, 0x0e, 0x0b, 0x0b, 0x88, 0x01, 0x0f, 0x00, 0x00, 0x0b,
        0x2e, 0x01, 0x6e, 0x0e, 0x03, 0x0e, 0x3a, 0x0b, 0x3b, 0x0b, 0x49, 0x13, 0x20, 0x0b, 0x00,
        0x00, 0x0c, 0x34, 0x00, 0x03, 0x0e, 0x3a, 0x0b, 0x3b, 0x05, 0x49, 0x13, 0x00, 0x00, 0x0d,
        0x33, 0x01, 0x15, 0x13, 0x00, 0x00, 0x0e, 0x0d, 0x00, 0x49, 0x13, 0x88, 0x01, 0x0f, 0x38,
        0x0b, 0x34, 0x19, 0x00, 0x00, 0x0f, 0x19, 0x01, 0x16, 0x0b, 0x00, 0x00, 0x10, 0x2e, 0x01,
        0x11, 0x01, 0x12, 0x06, 0x40, 0x18, 0x6e, 0x0e, 0x03, 0x0e, 0x3a, 0x0b, 0x3b, 0x05, 0x49,
        0x13, 0x00, 0x00, 0x11, 0x05, 0x00, 0x02, 0x18, 0x03, 0x0e, 0x3a, 0x0b, 0x3b, 0x05, 0x49,
        0x13, 0x00, 0x00, 0x12, 0x0b, 0x01, 0x55, 0x17, 0x00, 0x00, 0x13, 0x34, 0x00, 0x02, 0x18,
        0x03, 0x0e, 0x88, 0x01, 0x0f, 0x3a, 0x0b, 0x3b, 0x05, 0x49, 0x13, 0x00, 0x00, 0x14, 0x1d,
        0x01, 0x31, 0x13, 0x11, 0x01, 0x12, 0x06, 0x58, 0x0b, 0x59, 0x05, 0x57, 0x0b, 0x00, 0x00,
        0x15, 0x34, 0x00, 0x02, 0x18, 0x31, 0x13, 0x00, 0x00, 0x16, 0x1d, 0x01, 0x31, 0x13, 0x55,
        0x17, 0x58, 0x0b, 0x59, 0x05, 0x57, 0x0b, 0x00, 0x00, 0x17, 0x0b, 0x01, 0x11, 0x01, 0x12,
        0x06, 0x00, 0x00, 0x18, 0x1d, 0x01, 0x31, 0x13, 0x11, 0x01, 0x12, 0x06, 0x58, 0x0b, 0x59,
        0x0b, 0x57, 0x0b, 0x00, 0x00, 0x19, 0x34, 0x00, 0x02, 0x18, 0x03, 0x0e, 0x3a, 0x0b, 0x3b,
        0x05, 0x49, 0x13, 0x00, 0x00, 0x1a, 0x24, 0x00, 0x03, 0x0e, 0x3e, 0x0b, 0x0b, 0x0b, 0x00,
        0x00, 0x1b, 0x0f, 0x00, 0x49, 0x13, 0x33, 0x06, 0x00, 0x00, 0x1c, 0x0f, 0x00, 0x49, 0x13,
        0x03, 0x0e, 0x33, 0x06, 0x00, 0x00, 0x1d, 0x15, 0x01, 0x49, 0x13, 0x00, 0x00, 0x1e, 0x05,
        0x00, 0x49, 0x13, 0x00, 0x00, 0x1f, 0x01, 0x01, 0x49, 0x13, 0x00, 0x00, 0x20, 0x21, 0x00,
        0x49, 0x13, 0x22, 0x0d, 0x37, 0x0b, 0x00, 0x00, 0x21, 0x24, 0x00, 0x03, 0x0e, 0x0b, 0x0b,
        0x3e, 0x0b, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn test_parse_abbrev() {
        let raw = [
            0x01, 0x11, 0x01, 0x25, 0x0e, 0x13, 0x05, 0x03, 0x0e, 0x10, 0x17, 0x1b, 0x0e, 0xb4,
            0x42, 0x19, 0x11, 0x01, 0x55, 0x17, 0x00, 0x00, 0x02, 0x39, 0x01, 0x03, 0x0e, 0x00,
            0x00, 0x03, 0x04, 0x01, 0x49, 0x13, 0x6d, 0x19, 0x03, 0x0e, 0x0b, 0x0b, 0x88, 0x01,
            0x0f, 0x00, 0x00, 0x04, 0x28, 0x00, 0x03, 0x0e, 0x1c, 0x0f, 0x00, 0x00, 0x05, 0x13,
            0x01, 0x03, 0x0e, 0x0b, 0x0b, 0x88, 0x01, 0x0f, 0x00, 0x00,
        ];
        let (abbrev, bytes) = parse_abbrev(&raw).unwrap();
        assert_eq!(bytes, 22);
        assert_eq!(abbrev.abbrev_code, 0x1);
        assert_eq!(abbrev.tag, DW_TAG_compile_unit);
        assert!(abbrev.has_children);
        let mut pos = bytes as usize;

        let (abbrev, bytes) = parse_abbrev(&raw[pos..]).unwrap();
        assert_eq!(bytes, 7);
        assert_eq!(abbrev.abbrev_code, 0x2);
        assert_eq!(abbrev.tag, DW_TAG_namespace);
        assert!(abbrev.has_children);
        pos += bytes;

        let (abbrev, bytes) = parse_abbrev(&raw[pos..]).unwrap();
        assert_eq!(bytes, 16);
        assert_eq!(abbrev.abbrev_code, 0x3);
        assert_eq!(abbrev.tag, DW_TAG_enumeration_type);
        assert!(abbrev.has_children);
        pos += bytes;

        let (abbrev, bytes) = parse_abbrev(&raw[pos..]).unwrap();
        assert_eq!(bytes, 9);
        assert_eq!(abbrev.abbrev_code, 0x4);
        assert!(!abbrev.has_children);
        pos += bytes;

        let (abbrev, bytes) = parse_abbrev(&raw[pos..]).unwrap();
        assert_eq!(bytes, 12);
        assert_eq!(abbrev.abbrev_code, 0x5);
        assert!(abbrev.has_children);
        pos += bytes;
    }

    #[test]
    fn test_parse_cu_abbrevs() {
        let raw = [
            0x01, 0x11, 0x01, 0x25, 0x0e, 0x13, 0x05, 0x03, 0x0e, 0x10, 0x17, 0x1b, 0x0e, 0xb4,
            0x42, 0x19, 0x11, 0x01, 0x55, 0x17, 0x00, 0x00, 0x02, 0x39, 0x01, 0x03, 0x0e, 0x00,
            0x00, 0x03, 0x04, 0x01, 0x49, 0x13, 0x6d, 0x19, 0x03, 0x0e, 0x0b, 0x0b, 0x88, 0x01,
            0x0f, 0x00, 0x00, 0x04, 0x28, 0x00, 0x03, 0x0e, 0x1c, 0x0f, 0x00, 0x00, 0x05, 0x13,
            0x01, 0x03, 0x0e, 0x0b, 0x0b, 0x88, 0x01, 0x0f, 0x00, 0x00, 0x00,
        ];
        let (abbrevs, bytes) = parse_cu_abbrevs(&raw).unwrap();
        assert_eq!(abbrevs.len(), 0x5);
        assert_eq!(bytes, raw.len());
    }

    #[test]
    fn test_unititer() {
        let iter = UnitIter::new(&test_info, &test_abbrev);
        let mut cnt = 0;
        let mut die_cnt = 0;
        let mut attr_cnt = 0;
        let mut subprog_cnt = 0;
        for (_uh, dieiter) in iter {
            cnt += 1;
            for die in dieiter {
                die_cnt += 1;
                if die.tag == DW_TAG_subprogram {
                    subprog_cnt += 1;
                }
                for (_name, _form, _opt, _value) in die {
                    attr_cnt += 1;
                }
            }
        }
        assert_eq!(cnt, 1);
        assert_eq!(die_cnt, 252);
        assert_eq!(subprog_cnt, 12);
        assert_eq!(attr_cnt, 615);
    }
}
